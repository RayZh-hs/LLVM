# Quick Start Guide

This quick start walks you through the public API that ships with this repository. Everything shown below compiles against the sources in `src/main/kotlin`â€”no unpublished DSLs or helpers required.

## Prerequisites

- Kotlin/JVM project (any build tool is fine; the repository itself uses Gradle)
- Basic familiarity with LLVM IR concepts helps when reading the printed output

## Step 1: Create a Module and Function

```kotlin
import space.norb.llvm.structure.Module
import space.norb.llvm.builder.IRBuilder
import space.norb.llvm.types.FunctionType
import space.norb.llvm.types.IntegerType

fun main() {
    val module = Module("quick_start")
    module.targetTriple = "x86_64-pc-linux-gnu"
    module.dataLayout = "e-m:e-i64:64-f80:128-n8:16:32:64-S128"

    val functionType = FunctionType(
        returnType = IntegerType.I32,
        paramTypes = listOf(IntegerType.I32, IntegerType.I32)
    )

    val function = module.registerFunction("add", functionType)
    val entryBlock = function.insertBasicBlock("entry", setAsEntrypoint = true)

    val builder = IRBuilder(module)
    builder.positionAtEnd(entryBlock)

    val lhs = function.parameters[0]
    val rhs = function.parameters[1]

    val sum = builder.insertAdd(lhs, rhs, "sum")
    builder.insertRet(sum)

    println(module.toIRString())
}
```

Running the program prints the LLVM IR generated by `IRPrinter`:

```llvm
; Module: quick_start

define i32 @add(i32 %arg0, i32 %arg1) {

  entry:
    %sum = add i32 %arg0, %arg1
    ret i32 %sum
}
```

## Step 2: Work with Control Flow

Control flow is built by creating additional blocks and positioning the builder before inserting terminators.

```kotlin
import space.norb.llvm.enums.IcmpPredicate

val thenBlock = function.insertBasicBlock("then")
val elseBlock = function.insertBasicBlock("else")

builder.positionAtEnd(entryBlock)
val comparison = builder.insertICmp(IcmpPredicate.SGT, lhs, rhs, "cmp")
builder.insertCondBr(comparison, thenBlock, elseBlock)

builder.positionAtEnd(thenBlock)
builder.insertRet(lhs)

builder.positionAtEnd(elseBlock)
builder.insertRet(rhs)
```

The same builder instance can be reused as long as you position it at the block you want to populate.

## Step 3: Allocate and Access Memory

Use the memory helpers exposed by `IRBuilder` for stack allocation, stores, loads, and GEPs. Remember that pointers are un-typed in this codebase (all pointers print as `ptr`).

```kotlin
import space.norb.llvm.builder.BuilderUtils

builder.positionAtEnd(entryBlock)
val slot = builder.insertAlloca(IntegerType.I32, "slot")
builder.insertStore(sum, slot)
val reloaded = builder.insertLoad(IntegerType.I32, slot, "reloaded")

val zeroIndex = BuilderUtils.getIntConstant(0, IntegerType.I32)
val elementPtr = builder.insertGep(IntegerType.I32, slot, listOf(zeroIndex), "gep")
```

## Step 4: Add Globals When Needed

Global variables are created via the factory helpers on `GlobalVariable`. They are always stored as un-typed pointers but keep track of the element type for IR printing.

```kotlin
import space.norb.llvm.values.constants.IntConstant
import space.norb.llvm.values.globals.GlobalVariable

val counter = GlobalVariable.createWithElementType(
    name = "counter",
    elementType = IntegerType.I32,
    module = module,
    initializer = IntConstant(0L, IntegerType.I32)
)
module.registerGlobalVariable(counter)
```

## What to Explore Next

- Browse the unit and integration tests under `src/test` for more idiomatic patterns (phi nodes, switches, indirect calls, casts)
- Read the [API documentation](../api/README.md) for per-component details
- Consult the [Getting Started guide](../guides/getting-started.md) for project setup notes and tips on printing/validating IR